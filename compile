#! /usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import with_statement
from machine_translator import Translate
from statements import *

def strip_comment(line):
    pos = line.find('--')
    if pos == -1:
        return line
    else:
        return line[:pos]

class ParseError(Exception):
    pass

class RGB(object):
    def __init__(self, r, g, b):
        self.r = r
        self.g = g
        self.b = b

    def __repr__(self):
        return "RGB(%i, %i, %i)" % (self.r, self.g, self.b)

class TimeError(Exception):
    pass

class Time(object):
    def __init__(self, time=0):
        self.time = time

    def from_string(self, string):
        for (end, mult) in [('ms', 1), ('s', 1000)]:
            if string.endswith(end):
                time = string[:-len(end)]
                if time.isdigit():
                    time = int(time) * mult
                    if (time <= 0) or (time > 255):
                        raise TimeError('time must be 1ms to 255ms long')
                    self.time = time
                    break
                else:
                    raise TimeError('bad time value (%s)' % time)
        else:
            raise TimeError("unknown time unit")
        return self

class IndentError(Exception):
    pass

def indent_level(line):
    """Get the level of indentation on 'line.' Indentation must be done with 
    spaces and the number of spaces must be a multiple of four.

    Example
        >>> indent_level('to 255 0 0')
        0
        >>> indent_level('    to 255 0 0') # 4 spaces
        1
    """
    spaces = 0
    for ch in line:
        if ch == ' ':
            spaces += 1
        elif ch.isspace(): # nothing but spaces are valid for indenation
            raise IndentError("indentation is done with spaces (got %r)" \
                % ch)
        else:
            break
    if spaces % 4 == 0:
        return spaces // 4
    else:
        raise IndentError("indentation level could not be determined")

def parse(lines):
    def parse_do(args):
        if len(args) == 0:
            raise ParseError("missing argument to 'do' statement")
        elif len(args) == 1:
            if args[0] == 'forever':
                return DoStatement(forever=True)
        elif len(args) == 2:
            if args[0].isdigit() and args[1] == 'times':
                return DoStatement(times=int(args[0]))
        else:
            raise ParseError("too many arguments to 'do' statement")

    def check_color(args):
        try:
            for arg in args:
                if arg.isdigit():
                    val = int(arg)
                    if (0 <= val and val <= 255):
                        continue
                raise ParseError("bad RGB value %r" % arg)
        except ParseError, e:
            return (False, str(e))
        return (True, '')

    def parse_to(args, go_back_color):
        if len(args) > 12:
            raise ParseError("too many arguments to 'to'")
        def off(i):
            return args[i]
        
        ok, msg = check_color(args[:3])
        if not ok:
            raise ParseError(msg)
        
        color = RGB(*[int(i) for i in args[:3]])
        sm = ToStatement(color)

        o = 3
        if len(args) == o:
            return sm
        
        if off(o) == 'in':
            try:
                temp_time = Time()
                sm.time = temp_time.from_string(off(o+1)).time
            except TimeError, e:
                raise ParseError(e)
            o += 2

            if len(args) == o:
                raise ParseError("missing 'from' color")

            if off(o) == 'from':
                if len(args) < o + 3:
                    raise ParseError("expecting color (three-tuple)")
                else:
                    o += 1
                    color = [args[o], args[o+1], args[o+2]]
                    ok, msg = check_color(color)
                    if ok:
                        sm.from_color = RGB(*[int(i) for i in color])
                        o += 3
                        if len(args) == o:
                            return sm
                    else:
                        raise ParseError(msg)
            else:
                raise ParseError("bad keyword %r, expecting 'from'" % off(o))


        if off(o) == 'on':
            if off(o+1) == 'channel':
                chan = off(o+2) 
                if chan.isdigit():
                    sm.channel = int(chan)
                    o += 3
                    if len(args) == o:
                        return sm
                else:
                    ParseError("bad channel value %r" % chan)
            else:
                raise ParseError("expecting 'channel'")

        if not off(o) in ['and', 'in', 'on']:
            raise ParseError("unexpected argument %r" % off(o))

        return sm

    def parse_wait(args):
        if len(args) != 1:
            raise ParseError("bad number of arguments to 'wait'")
        try:
            time_obj = Time()
            time_obj.from_string(args[0])
        except TimeError, e:
            raise ParseError(e)
        sm = WaitStatement(time_obj.time)
        return sm
    
    # Register our parsers.
    parsers = {}
    for (name, value) in locals().iteritems():
        begner = 'parse_'
        if name.startswith(begner):
            parsers[name[len(begner):]] = value

    parsed = []
    def check_indent(this_indent):
        if len(parsed) != 0:
            last = parsed[-1]
            if type(last) == DoStatement:
                if this_indent <= last.indent:
                   raise ParseError("empty 'do' block")
                elif this_indent > last.indent + 1:
                   raise ParseError("too large indendation increase")
    
    lines.append('') # we want to check that the indentation on the real last 
                     # line is OK
    for (line, idx) in zip(lines, range(len(lines))):
        go_back = RGB(0, 0, 0)
        if len(parsed) != 0 and type(parsed[-1]) == ToStatement:
            if parsed[-1].go_back == False:
                go_back = parsed[-1].color
            else:
                go_back = parsed[-1].go_back

        words = strip_comment(line).lower().split()
        
        try:
            indent = indent_level(line)
        except IndentError, e:
            raise ParseError("%s on line %i: %r" % (e, idx+1, line))

        if len(words) == 0:
            check_indent(indent)
            continue

        statement = words[0]
        args = words[1:]
        if statement in parsers:
            try:
                check_indent(indent)
                if statement == 'to':
                    sm = parsers[statement](args, go_back)
                else:
                    sm = parsers[statement](args)
                sm.indent = indent
                parsed.append(sm)

            except ParseError, e:
                err = "%s on line %i: %r" % (e, idx+1, line)
                raise ParseError(err)
            except Exception, e:
                raise
                raise ParseError("Bad line: %r" % line)
        else:
            raise ParseError("Bad line: %r" % line)

    def tree(first, rest):
        if type(first) == DoStatement:
            children = Statements()
            stop = rest
            for r in rest:
                if r.indent > first.indent:
                    stop = stop[1:]
                    children.append(r)
                else:
                    break

            first.statements = tree(children[0], children[1:])
            if len(stop) == 0:
                return [first]
            else:
                return [first] + tree(stop[0], stop[1:])
        else:
            if len(rest) == 0:
                return [first]
            else:
                return [first] + tree(rest[0], rest[1:])
    
    if len(parsed) == 0:
        return []
    else:
        return tree(parsed[0], parsed[1:])

def main(args):
    if len(args) != 2:
        return "Usage: %s <file>" % args[0]
    
    file = args[1]

    try:
        translator = Translate()
        with open(file, 'r') as f:
            code_lines = [line[:-1] for line in f.xreadlines()]
            tree = parse(code_lines)
            translator.traverse(tree)

        dotpos = file.rfind('.dmx')
        if dotpos == -1:
            out_file = file + '.m'
        else:
            out_file = file[:dotpos] + '.m'

        with open(out_file, 'w') as f:
            f.write("%s" % translator)

    except IOError, e:
        return "Could not open %r for reading." % file
    except ParseError, e:
        return str(e).capitalize()
    else:
        return 0

if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))
